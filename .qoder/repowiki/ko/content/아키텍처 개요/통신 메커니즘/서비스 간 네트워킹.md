# 서비스 간 네트워킹

<cite>
**이 문서에서 참조한 파일**  
- [docker-compose.yml](file://docker-compose.yml)
- [config.py](file://aperag/config.py)
- [api-service.yaml](file://deploy/aperag/templates/api-service.yaml)
- [values.yaml](file://deploy/aperag/values.yaml)
</cite>

## 목차
1. [소개](#소개)  
2. [Docker Compose 기반 네트워크 구성](#docker-compose-기반-네트워크-구성)  
3. [Kubernetes 환경의 서비스 디스커버리](#kubernetes-환경의-서비스-디스커버리)  
4. [동적 서비스 URL 로딩 및 환경별 설정](#동적-서비스-url-로딩-및-환경별-설정)  
5. [보안 및 통신 보장 메커니즘](#보안-및-통신-보장-메커니즘)  
6. [결론](#결론)

## 소개
ApeRAG은 백엔드 API, 프론트엔드 UI, 데이터베이스(PostgreSQL), 벡터 저장소(Qdrant), 캐시(Redis), 검색 엔진(Elasticsearch) 등 다양한 서비스로 구성된 복합 아키텍처를 갖춘 RAG(Retrieval-Augmented Generation) 플랫폼입니다. 이 문서는 ApeRAG 내부의 서비스 간 네트워크 연결 방식을 분석하며, Docker Compose와 Kubernetes 환경에서의 통신 구조, 의존성 관계, 동적 설정 로딩, 보안 정책 등을 설명합니다.

## Docker Compose 기반 네트워크 구성

```mermaid
graph TB
subgraph "애플리케이션 서비스"
API[API 서버<br/>포트: 8000]
Frontend[프론트엔드<br/>포트: 3000]
CeleryWorker[Celery Worker]
CeleryBeat[Celery Beat]
Flower[Flower 모니터링]
end
subgraph "인프라 서비스"
Postgres[(PostgreSQL<br/>포트: 5432)]
Redis[(Redis<br/>포트: 6379)]
Qdrant[(Qdrant<br/>포트: 6333)]
ES[(Elasticsearch<br/>포트: 9200)]
Jaeger[Jaeger Tracing]
end
API --> Postgres
API --> Redis
API --> Qdrant
API --> ES
Frontend --> API
CeleryWorker --> Redis
CeleryWorker --> Postgres
CeleryWorker --> Qdrant
CeleryWorker --> ES
CeleryBeat --> Redis
CeleryBeat --> Postgres
Flower --> Redis
Flower --> Postgres
```

**다이어그램 출처**  
- [docker-compose.yml](file://docker-compose.yml)

**섹션 출처**  
- [docker-compose.yml](file://docker-compose.yml)

### 컨테이너 간 통신 및 포트 매핑
`docker-compose.yml` 파일을 기반으로 ApeRAG은 다음과 같은 네트워크 설정을 사용합니다:
- **내부 통신**: 모든 컨테이너는 Docker의 기본 브리지 네트워크를 통해 호스트 이름(`api`, `postgres`, `redis` 등)으로 상호 연결됩니다.
- **외부 접근용 포트 매핑**:
  - `api`: 외부 8000 → 컨테이너 8000 (`http://localhost:8000`)
  - `frontend`: 외부 3000 → 컨테이너 3000 (`http://localhost:3000`)
  - `postgres`: 5432 (외부 DB 접근 가능)
  - `redis`: 6379
  - `qdrant`: 6333
  - `es`: 9200
  - `flower`: 5555 (모니터링 대시보드)

### 서비스 의존성 및 시작 순서
`depends_on`과 `healthcheck`를 통해 서비스 간 종속성을 명확히 정의하고 있습니다:
- `api`, `celeryworker`, `celerybeat`, `flower`는 `redis`, `postgres`, `qdrant`, `es`가 정상 상태일 때만 시작됩니다.
- 각 인프라 서비스는 자체 헬스체크를 통해 준비 상태를 확인합니다 (예: `pg_isready`, `redis-cli ping`).

## Kubernetes 환경의 서비스 디스커버리

```mermaid
graph LR
Client[외부 클라이언트] --> Ingress[Ingress Controller]
Ingress --> FrontendService[frontend-service]
Ingress --> ApiService[api-service]
FrontendService --> FrontendPods[frontend Pod(s)]
ApiService --> ApiPods[api Pod(s)]
ApiPods --> PostgresSvc[PostgreSQL Service]
ApiPods --> RedisSvc[Redis Service]
ApiPods --> QdrantSvc[Qdrant Service]
ApiPods --> EsSvc[Elasticsearch Service]
CeleryWorker --> RedisSvc
CeleryWorker --> PostgresSvc
CeleryBeat --> RedisSvc
CeleryBeat --> PostgresSvc
```

**다이어그램 출처**  
- [api-service.yaml](file://deploy/aperag/templates/api-service.yaml)
- [values.yaml](file://deploy/aperag/values.yaml)

**섹션 출처**  
- [api-service.yaml](file://deploy/aperag/templates/api-service.yaml)
- [values.yaml](file://deploy/aperag/values.yaml)

### 서비스 디스커버리 및 DNS 해상도
Kubernetes에서는 다음과 같은 방식으로 서비스를 발견하고 통신합니다:
- **내부 DNS**: Pod는 `<service-name>.<namespace>.svc.cluster.local` 형식의 도메인을 통해 다른 서비스에 접근합니다. 예: `api.aperag.svc.cluster.local`.
- **Headless 서비스 활용**: 현재 `api-service.yaml`은 일반 클러스터 IP 서비스이며, headless 서비스는 사용하지 않습니다. 그러나 고가용성 또는 상태 기반 라우팅이 필요할 경우 `clusterIP: None` 설정으로 전환 가능합니다.
- **Ingress를 통한 외부 노출**: `ingress.yaml`을 통해 HTTP(S) 트래픽을 `frontend-service`와 `api-service`로 라우팅합니다.

### Helm values.yaml을 통한 유연한 구성
`values.yaml`은 각 서비스의 복제본 수, 리소스 제한, 환경 변수 등을 중앙에서 관리할 수 있도록 하며, 환경별(개발/운영)로 서로 다른 값을 적용할 수 있습니다.

## 동적 서비스 URL 로딩 및 환경별 설정

```mermaid
flowchart TD
Start([Config 로드 시작]) --> LoadEnv[".env 파일 로드"]
LoadEnv --> CheckDB["DATABASE_URL 존재 여부 확인"]
CheckDB --> |없음| BuildPostgresURL["POSTGRES_* 환경변수로 URL 생성"]
CheckDB --> |있음| UseExistingURL["기존 DATABASE_URL 사용"]
BuildPostgresURL --> SetDBURL["settings.database_url 설정"]
UseExistingURL --> SetDBURL
SetDBURL --> BuildRedisURL["REDIS_* 변수로 CELERY_BROKER_URL 생성"]
BuildRedisURL --> SetCeleryURL["settings.celery_broker_url 설정"]
SetCeleryURL --> BuildESHost["ES_* 변수로 es_host 생성"]
BuildESHost --> SetESHost["settings.es_host 설정"]
SetESHost --> LoadModelConfigs["model_configs.json 로드"]
LoadModelConfigs --> InitComplete["설정 초기화 완료"]
```

**다이어그램 출처**  
- [config.py](file://aperag/config.py)

**섹션 출처**  
- [config.py](file://aperag/config.py)

### config.py를 통한 동적 설정
`config.py`는 환경 변수와 파일 기반 설정을 결합하여 서비스 URL을 동적으로 구성합니다:
- **데이터베이스 URL**: `POSTGRES_HOST`, `PORT`, `USER`, `PASSWORD` 등을 조합해 `postgresql://...` 형식의 URL 생성.
- **Redis URL**: `CELERY_BROKER_URL`과 `MEMORY_REDIS_URL`을 `redis://...` 형식으로 자동 생성.
- **Elasticsearch URL**: 인증 정보 포함 여부에 따라 `http://user:pass@host:port` 또는 `http://host:port` 생성.
- **모델 설정**: `model_configs.json` 파일을 읽어 LLM 모델 정보를 동적으로 로드.

### 환경별 구성 차이
- **로컬 개발**: `docker-compose.yml`에서 `.env` 및 `envs/docker.env.overrides`를 로드하여 로컬 호스트 기반 설정 사용.
- **운영 환경(K8s)**: `values.yaml`에서 환경 변수를 주입하거나 Secret을 통해 민감 정보를 전달.

## 보안 및 통신 보장 메커니즘

### TLS 암호화
- 현재 `docker-compose.yml` 및 `config.py`에는 HTTPS/TLS 관련 설정이 명시적으로 포함되어 있지 않으며, HTTP 기반 통신을 사용합니다.
- 운영 환경에서는 Ingress 또는 Istio와 같은 서비스 메시를 통해 TLS 종료(Termination)를 적용하는 것이 권장됩니다.

### 서비스 메시(Istio 등) 연동 가능성
- Istio와 같은 서비스 메시를 도입하면 다음과 같은 이점을 얻을 수 있습니다:
  - mTLS(Mutual TLS)를 통한 서비스 간 암호화
  - 트래픽 라우팅 및 회로 차단(Circuit Breaking)
  - 관측 가능성(Tracing, Metrics, Logging) 강화
- 현재 ApeRAG은 OpenTelemetry/Jaeger를 통해 분산 추적을 지원하므로 Istio와의 통합이 용이합니다.

### 네트워크 정책 및 방화벽 설정
- **Kubernetes NetworkPolicy**: 특정 Pod 간의 통신만 허용하도록 제한 가능 (예: `api` Pod만 `postgres` 서비스에 접근).
- **Ingress/Egress Rule**: 외부 트래픽은 Ingress를 통해서만 허용하고, 외부로 나가는 트래픽(Egress)은 필요한 엔드포인트로만 제한.
- **보안 그룹**(클라우드 환경): EC2 또는 VM 기반 배포 시, 보안 그룹을 통해 포트별 접근 제어.

## 결론
ApeRAG은 Docker Compose와 Kubernetes 모두에서 안정적인 서비스 간 통신을 위한 체계적인 네트워크 구조를 제공합니다. `docker-compose.yml`을 통한 명확한 의존성 관리, `config.py`를 통한 동적 설정 로딩, 그리고 `Helm values.yaml` 기반의 유연한 운영 구성이 핵심입니다. 보안 측면에서는 현재 HTTP 기반 통신을 사용하지만, Istio와 같은 서비스 메시 도입을 통해 mTLS 및 고급 네트워크 정책을 적용함으로써 보안성을 크게 강화할 수 있습니다. 또한, Ingress와 NetworkPolicy를 적절히 구성하면 외부 공격으로부터의 노출을 최소화할 수 있습니다.